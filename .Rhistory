## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
counter <- counter + 1
}
store.rmse
coef(lm.full)
length(coef(lm.full))
store.p <- matrix(0, 0, length(coef(lm.full)))
store.p
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
store.p
equ <- as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50)
lm.full <- lm(equ, data = d)
summary(lm.full)
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
summary(lm.full)
## GET 10% SAMPLE SIZE FOR LEAVE-OUT
n <- round(nrow(d) * 0.1)
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
}
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
get.OPlurValidated()
ds <- read.csv("I:\\Projects_Other\\EXPOSOMICS\\OP_LUR\\LUR models\\INDIVIDUAL MODELS\\NL.csv")
ds <- ds[ -c(2),] ## REMOVE ANY OUTLIER ROWS
equation <- as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50) ## REMOVE ANY OUTLIER ROWS
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
get.OPlurValidated(equation, ds)
store.r2
store.rmse
store.p
get.OPlurValidated(equation, ds)
store.r2
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
summary(lm.full)
## GET 10% SAMPLE SIZE FOR LEAVE-OUT
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
return(valid.out)
}
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.common
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
summary(lm.full)
## GET 10% SAMPLE SIZE FOR LEAVE-OUT
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(store.p)
return(valid.out)
}
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.common
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
summary(lm.full)
## GET 10% SAMPLE SIZE FOR LEAVE-OUT
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.p)
return(valid.out)
}
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.common
summary(NL.common)
require(ggplot2)
ggplot(data = NL.common, aes(y = R2)) + geom_boxplot()
ggplot(data = NL.common, aes(x = R2)) + geom_boxplot()
ggplot(data = NL.common, aes(x = 1, y = R2)) + geom_boxplot()
ggplot(data = NL.common, aes(x = "R2", y = R2)) + geom_boxplot()
melt(NL.common[, 3:5])
require(reshape)
melt(NL.common[, 3:5])
ggplot(data = melt(NL.common[, 3:5]), aes(x = variable, y = value)) + geom_boxplot()
ggplot(data = NL.common, aes(x = "RMSE", y = rmse)) + geom_boxplot()
summary(NL.common)
ggplot(data = NL.common, aes(x = "RMSE", y = RMSE)) + geom_boxplot()
summary(NL.common)
rm(list=ls(all=T)) ## To clean workspace.
a <- "C:/atest"
###############################################################
#2. Generating a vector with the path of each txt file
inicio <- dir(a,recursive=T,full.names=T)
inicio
rm(list=ls(all=T)) ## To clean workspace.
a <- "C:/atest"
###############################################################
#2. Generating a vector with the path of each txt file
inicio <- dir(a,recursive=T,full.names=T)
inicio
inicio2 <- grep("RData",grep(".las",dir(a,recursive=T,full.names=T),invert =T,value=T),invert =T,value=T)
inicio2
inicio3 <- do.call(rbind,lapply(inicio2,function(x)file.info(x)["size"]))
inicio4 <- rownames(inicio3)[inicio3$size!=0]
###############################################################
#3. Loading function converting from sexagesimal coordinates to decimal coordinates
source("C:\\Users\\dwmorley\\Desktop\\gps.R")
source("I:\\Projects_Other\\EXPOSOMICS\\GPS Tracker\\gps.R")
gps.data <- lapply(inicio4,gps)
names(gps.data) <- gsub("(.*/)|(_.*)","",inicio4)
sapply(gps.data,dim)
table(table(names(gps.data)))
gps.dat2 <- lapply(unique(names(gps.data)),function(x){
if(length(gps.data[x])==1) result <- gps.data[[x]]
if(length(gps.data[x])>1) result <- do.call(rbind,gps.data[x])
result
})
names(gps.dat2) <- unique(names(gps.data))
sapply(gps.dat2,dim)
table(table(names(gps.dat2)))
gps.dat2
head(gps.dat2)
head(gps.dat2)
head(gps.dat2$test)
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_500 + TRAFMAJORLOAD_50), ds)
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
summary(lm.full)
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.p)
return(valid.out)
}
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_500 + TRAFMAJORLOAD_50), ds)
ds <- read.csv("I:\\Projects_Other\\EXPOSOMICS\\OP_LUR\\LUR models\\INDIVIDUAL MODELS\\NL.csv")
ds <- ds[ -c(2),] ## REMOVE ANY OUTLIER ROWS
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_500 + TRAFMAJORLOAD_50), ds)
summary(NL.common)
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
get.OPlurValidated <- function(equ, d) {
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
print(summary(lm.full))
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.p)
return(valid.out)
}
NL.common <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.common
ds <- read.csv("I:\\Projects_Other\\EXPOSOMICS\\OP_LUR\\LUR models\\INDIVIDUAL MODELS\\NL.csv")
ds <- ds[ -c(2),] ## REMOVE ANY OUTLIER ROWS
names(ds)
NL.local <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.local
summary(NL.local)
NL.local <- get.OPlurValidated(as.formula(OPAA ~ POPEEA_5000 + TRAFMAJORLOAD_50), ds)
NL.local
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
?a
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
?h3
?actionButton
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
?htmlOutput
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
