## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
store.c <- rbind(store.c, summary(this.lm)$coefficients[, 1])
## STORE OBS, PRED
store.10.obs <- append(store.10.obs, this.validation[, as.character(equ)[2]])
store.10.pred <- append(store.10.pred, this.predict)
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.c)
store.p <- data.frame(store.p)
names(store.p) <- paste0(names(store.p), "_p")
valid.out <- cbind(valid.out, store.p)
##OUTPUT 10% ONLY##
valid.out <- data.frame(obs = store.10.obs, pred = store.10.pred)
######
return(valid.out)
}
set.seed(123)
equ.nl.aa.strict <- as.formula(OPAA ~ TRAFLOAD_50 + POPEEA_5000) #(or HHOLD_100)
equ.nl.gsh.strict <- as.formula(OPGSH ~ INTMAJORINVDIST + NATURAL_5000) #(or UGNL_5000)
summary(lm(equ.nl.aa.strict, data = nl.aa))
nl.aa.strict <- get.OPlurValidated(equ.nl.aa.strict, nl.aa)
nl.aa.strict
op.10.plot(nl.aa.strict, "Netherlands OPAA")
dev.off()
op.10.plot(nl.aa.strict, "Netherlands OPAA")
op.10.plot <- function(data, title) {
tx <-  paste(
paste0("R-Sq: ", round(summary(lm(data$obs ~ data$pred))$r.squared, 4)),
paste0("RMSE: ", round(summary(lm(data$obs ~ data$pred))$sigma, 4)), sep = '   '
)
plot(data, main = paste(title, validation, " "), xlab = "Observed", ylab = "Predicted")
xpos <- range(data[, 1])[1] + ((range(data[, 1])[2] - range(data[, 1])[1]) / 1.5)
ypos <- range(data[, 2])[1] + 0.5
text(xpos, ypos, tx)
abline(0,1, lty = 2)
abline(lm(data$obs ~ data$pred))
}
op.10.plot(nl.aa.strict, "Netherlands OPAA")
op.10.plot <- function(data, title) {
tx <-  paste(
paste0("R-Sq: ", round(summary(lm(data$obs ~ data$pred))$r.squared, 4)),
paste0("RMSE: ", round(summary(lm(data$obs ~ data$pred))$sigma, 4)), sep = '   '
)
plot(data, main = paste(title, "validation", " "), xlab = "Observed", ylab = "Predicted")
xpos <- range(data[, 1])[1] + ((range(data[, 1])[2] - range(data[, 1])[1]) / 1.5)
ypos <- range(data[, 2])[1] + 0.5
text(xpos, ypos, tx)
abline(0,1, lty = 2)
abline(lm(data$obs ~ data$pred))
}
op.10.plot(nl.aa.strict, "Netherlands OPAA")
op.10.plot(nl.gsh.strict, "Netherlands GSH")
nl.gsh.strict
op.10.plot(nl.gsh.strict, "Netherlands GSH")
get.OPlurValidated <- function(equ, d) {
#  equ <- equ.nl.gsh.strict
#  d <- nl.gsh
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
print(summary(lm.full))
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
store.c <- matrix(0, 0, length(coef(lm.full)))
store.10.obs <- vector()
store.10.pred <- vector()
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
store.c <- rbind(store.c, summary(this.lm)$coefficients[, 1])
## STORE OBS, PRED
store.10.obs <- append(store.10.obs, this.validation[, as.character(equ)[2]])
store.10.pred <- append(store.10.pred, this.predict)
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.c)
store.p <- data.frame(store.p)
names(store.p) <- paste0(names(store.p), "_p")
valid.out <- cbind(valid.out, store.p)
##OUTPUT 10% ONLY##
# valid.out <- data.frame(obs = store.10.obs, pred = store.10.pred)
######
return(valid.out)
}
set.seed(123)
equ.nl.aa.strict <- as.formula(OPAA ~ TRAFLOAD_50 + POPEEA_5000) #(or HHOLD_100)
equ.nl.gsh.strict <- as.formula(OPGSH ~ INTMAJORINVDIST + NATURAL_5000) #(or UGNL_5000)
summary(lm(equ.nl.aa.strict, data = nl.aa))
nl.aa.strict <- get.OPlurValidated(equ.nl.aa.strict, nl.aa)
nl.aa.strict
summary(lm(equ.nl.gsh.strict, data = nl.gsh))
nl.gsh.strict <- get.OPlurValidated(equ.nl.gsh.strict, nl.gsh)
nl.gsh.strict
op.plot(nl.gsh.strict, "Netherlands GSH")
op.10.plot(nl.gsh.strict, "Netherlands GSH")
nl.gsh.strict
##############################
get.OPlurValidated <- function(equ, d) {
#  equ <- equ.nl.gsh.strict
#  d <- nl.gsh
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
print(summary(lm.full))
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
store.c <- matrix(0, 0, length(coef(lm.full)))
store.10.obs <- vector()
store.10.pred <- vector()
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
store.c <- rbind(store.c, summary(this.lm)$coefficients[, 1])
## STORE OBS, PRED
store.10.obs <- append(store.10.obs, this.validation[, as.character(equ)[2]])
store.10.pred <- append(store.10.pred, this.predict)
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.c)
store.p <- data.frame(store.p)
names(store.p) <- paste0(names(store.p), "_p")
valid.out <- cbind(valid.out, store.p)
##OUTPUT 10% ONLY##
valid.out <- data.frame(obs = store.10.obs, pred = store.10.pred)
######
return(valid.out)
}
set.seed(123)
equ.nl.aa.strict <- as.formula(OPAA ~ TRAFLOAD_50 + POPEEA_5000) #(or HHOLD_100)
equ.nl.gsh.strict <- as.formula(OPGSH ~ INTMAJORINVDIST + NATURAL_5000) #(or UGNL_5000)
summary(lm(equ.nl.aa.strict, data = nl.aa))
nl.aa.strict <- get.OPlurValidated(equ.nl.aa.strict, nl.aa)
nl.aa.strict
op.plot(nl.aa.strict, "Netherlands OPAA")
op.10.plot(nl.aa.strict, "Netherlands OPAA")
summary(lm(equ.nl.gsh.strict, data = nl.gsh))
nl.gsh.strict <- get.OPlurValidated(equ.nl.gsh.strict, nl.gsh)
nl.gsh.strict
op.plot(nl.gsh.strict, "Netherlands GSH")
op.10.plot(nl.gsh.strict, "Netherlands GSH")
dev.off()
op.10.plot(nl.gsh.strict, "Netherlands GSH")
op.10.plot(nl.gsh.strict, "Netherlands OPGSH")
get.OPlurValidated <- function(equ, d) {
#  equ <- equ.nl.gsh.strict
#  d <- nl.gsh
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
print(summary(lm.full))
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
store.c <- matrix(0, 0, length(coef(lm.full)))
store.10.obs <- vector()
store.10.pred <- vector()
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
store.c <- rbind(store.c, summary(this.lm)$coefficients[, 1])
## STORE OBS, PRED
store.10.obs <- append(store.10.obs, this.validation[, as.character(equ)[2]])
store.10.pred <- append(store.10.pred, this.predict)
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.c)
store.p <- data.frame(store.p)
names(store.p) <- paste0(names(store.p), "_p")
valid.out <- cbind(valid.out, store.p)
##OUTPUT 10% ONLY##
#valid.out <- data.frame(obs = store.10.obs, pred = store.10.pred)
######
return(valid.out)
}
set.seed(123)
equ.ch.aa.strict <- as.formula(OPAA ~ DISTNEAR + HDRES_500 + LDRES_100)
summary(lm(equ.ch.aa.strict, data = ch.aa))
ch.aa.strict <- get.OPlurValidated(equ.ch.aa.strict, ch.aa)
ch.aa.strict
## IT LOCAL STRICT MODEL
set.seed(123)
equ.it.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100) #(MAYBE NATURAL_1000 OR URBGREEN_500)
equ.it.gsh.strict <- as.formula(OPGSH ~ TRAFLOAD_1000 + INDUSTRY_1000) #(MAYBE UG_5000)
summary(lm(equ.it.aa.strict, data = it.aa))
it.aa.strict <- get.OPlurValidated(equ.it.aa.strict, it.aa)
it.aa.strict
summary(lm(equ.it.gsh.strict, data = it.gsh))
it.gsh.strict <- get.OPlurValidated(equ.it.gsh.strict, it.gsh)
it.gsh.strict
op.plot(it.gsh.strict, "Italy OPGSH")
set.seed(123)
equ.uk.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_50 + ROADLENGTH_1000)
summary(lm(equ.uk.aa.strict, data = uk.aa))
uk.aa.strict <- get.OPlurValidated(equ.uk.aa.strict, uk.aa)
uk.aa.strict
set.seed(123)
equ.sp.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100)
equ.sp.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_100 + MAJORROADLENGTH_1000)
summary(lm(equ.sp.aa.strict, data = sp.aa))
sp.aa.strict <- get.OPlurValidated(equ.sp.aa.strict, sp.aa)
sp.aa.strict
summary(lm(equ.sp.gsh.strict, data = sp.gsh))
sp.gsh.strict <- get.OPlurValidated(equ.sp.gsh.strict, sp.gsh)
sp.gsh.strict
set.seed(123)
equ.eu.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_50 + HDRES_1000 + INDUSTRY_5000)
equ.eu.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_50 + POP_100)
summary(lm(equ.eu.aa.strict, data = eu.aa))
eu.aa.strict <- get.OPlurValidated(equ.eu.aa.strict, eu.aa)
eu.aa.strict
summary(lm(equ.eu.gsh.strict, data = eu.gsh))
eu.gsh.strict <- get.OPlurValidated(equ.eu.gsh.strict, eu.gsh)
eu.gsh.strict
##############################
get.OPlurValidated <- function(equ, d) {
#  equ <- equ.nl.gsh.strict
#  d <- nl.gsh
## SET UP FULL MODEL
lm.full <- lm(equ, data = d)
print(summary(lm.full))
## GET 10% SAMPLE SIZE FOR LEAVE-OUTS
n <- round(nrow(d) * 0.1)
## STORE PERFORMANCE
store.r2 <- vector()
store.rmse <- vector()
store.p <- matrix(0, 0, length(coef(lm.full)))
store.c <- matrix(0, 0, length(coef(lm.full)))
store.10.obs <- vector()
store.10.pred <- vector()
## GET SUBSET
balls <- seq(1:nrow(d))
bucket <- rep(0, nrow(d))
counter <- 1
while (length(which(bucket != n)) >= n) {
print(paste0("Model: ", counter))
b.set <- FALSE
this.set <- vector()
while (!b.set) {
b.val <- FALSE
while(!b.val) {
draw <- sample(balls, 1)
# check if this draw is already in set or has not been already taken n times
if (!(draw %in% this.set) & bucket[draw] < n) {
# make sure bucket is not filling too fast
if (min(bucket[draw]) + 2 >= bucket[draw]) {
this.set <- append(this.set, draw)
bucket[draw] <- bucket[draw] + 1
b.val <- TRUE
}
}
}
# check if sample set is complete
if (length(this.set) == n) {
b.set <- TRUE
}
}
print(this.set)
## MODELLING
this.training <- d[-this.set, ]
this.validation <- d[this.set, ]
this.lm <- lm(equ, data = this.training)
print(round(summary(this.lm)$coefficients[, 4], 4))
print(summary(this.lm)$adj.r.squared)
## PREDICT
this.predict <- predict(this.lm, newdata = this.validation)
## STORE STATS
store.r2 <- append(store.r2, summary(this.lm)$adj.r.squared)
store.rmse <- append(store.rmse, summary(this.lm)$sigma)
store.p <- rbind(store.p, summary(this.lm)$coefficients[, 4])
store.c <- rbind(store.c, summary(this.lm)$coefficients[, 1])
## STORE OBS, PRED
store.10.obs <- append(store.10.obs, this.validation[, as.character(equ)[2]])
store.10.pred <- append(store.10.pred, this.predict)
counter <- counter + 1
}
## OUTPUT RESULTS
valid.out <- data.frame(R2 = store.r2, RMSE = store.rmse)
valid.out <- cbind(valid.out, store.c)
store.p <- data.frame(store.p)
names(store.p) <- paste0(names(store.p), "_p")
valid.out <- cbind(valid.out, store.p)
##OUTPUT 10% ONLY##
valid.out <- data.frame(obs = store.10.obs, pred = store.10.pred)
######
return(valid.out)
}
set.seed(123)
equ.ch.aa.strict <- as.formula(OPAA ~ DISTNEAR + HDRES_500 + LDRES_100)
summary(lm(equ.ch.aa.strict, data = ch.aa))
ch.aa.strict
ch.aa.strict <- get.OPlurValidated(equ.ch.aa.strict, ch.aa)
ch.aa.strict
op.10.plot(ch.aa.strict, "Switzerland OPAA")
dev.off()
op.10.plot(ch.aa.strict, "Switzerland OPAA")
set.seed(123)
equ.it.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100) #(MAYBE NATURAL_1000 OR URBGREEN_500)
equ.it.gsh.strict <- as.formula(OPGSH ~ TRAFLOAD_1000 + INDUSTRY_1000) #(MAYBE UG_5000)
summary(lm(equ.it.aa.strict, data = it.aa))
it.aa.strict <- get.OPlurValidated(equ.it.aa.strict, it.aa)
op.10.plot(it.aa.strict, "Italy OPAA")
summary(lm(equ.it.gsh.strict, data = it.gsh))
it.gsh.strict <- get.OPlurValidated(equ.it.gsh.strict, it.gsh)
it.gsh.strict
op.plot(it.gsh.strict, "Italy OPGSH")
op.10.plot(it.gsh.strict, "Italy OPGSH")
dev.off()
op.10.plot(it.gsh.strict, "Italy OPGSH")
set.seed(123)
equ.uk.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_50 + ROADLENGTH_1000)
summary(lm(equ.uk.aa.strict, data = uk.aa))
uk.aa.strict <- get.OPlurValidated(equ.uk.aa.strict, uk.aa)
uk.aa.strict
op.10.plot(uk.aa.strict, "UK OPAA")
set.seed(123)
equ.sp.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100)
equ.sp.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_100 + MAJORROADLENGTH_1000)
summary(lm(equ.sp.aa.strict, data = sp.aa))
sp.aa.strict <- get.OPlurValidated(equ.sp.aa.strict, sp.aa)
sp.aa.strict
op.10.plot(sp.aa.strict, "Spain OPAA")
summary(lm(equ.sp.gsh.strict, data = sp.gsh))
sp.gsh.strict <- get.OPlurValidated(equ.sp.gsh.strict, sp.gsh)
sp.gsh.strict
set.seed(123)
equ.sp.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100)
equ.sp.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_100 + MAJORROADLENGTH_1000)
summary(lm(equ.sp.aa.strict, data = sp.aa))
sp.aa.strict <- get.OPlurValidated(equ.sp.aa.strict, sp.aa)
sp.aa.strict
set.seed(123)
equ.sp.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_100)
equ.sp.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_100 + MAJORROADLENGTH_1000)
summary(lm(equ.sp.aa.strict, data = sp.aa))
sp.aa.strict <- get.OPlurValidated(equ.sp.aa.strict, sp.aa)
sp.aa.strict
op.10.plot(sp.aa.strict, "Spain OPAA")
summary(lm(equ.sp.gsh.strict, data = sp.gsh))
sp.gsh.strict <- get.OPlurValidated(equ.sp.gsh.strict, sp.gsh)
sp.gsh.strict
op.10.plot(sp.gsh.strict, "Spain OPGSH")
set.seed(123)
equ.eu.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_50 + HDRES_1000 + INDUSTRY_5000)
equ.eu.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_50 + POP_100)
summary(lm(equ.eu.aa.strict, data = eu.aa))
eu.aa.strict <- get.OPlurValidated(equ.eu.aa.strict, eu.aa)
eu.aa.strict
## ALL STRICT MODEL
set.seed(123)
equ.eu.aa.strict <- as.formula(OPAA ~ TRAFMAJORLOAD_50 + HDRES_1000 + INDUSTRY_5000)
equ.eu.gsh.strict <- as.formula(OPGSH ~ TRAFMAJORLOAD_50 + POP_100)
summary(lm(equ.eu.aa.strict, data = eu.aa))
eu.aa.strict <- get.OPlurValidated(equ.eu.aa.strict, eu.aa)
op.10.plot(eu.aa.strict, "Combined OPAA")
summary(lm(equ.eu.gsh.strict, data = eu.gsh))
eu.gsh.strict <- get.OPlurValidated(equ.eu.gsh.strict, eu.gsh)
eu.gsh.strict
op.plot(eu.gsh.strict, "Combined OPGSH")
op.10.plot(eu.gsh.strict, "Combined OPAA")
dev.off()
op.10.plot(eu.gsh.strict, "Combined OPAA")
op.10.plot(eu.gsh.strict, "Combined OPGSH")
require(shiny)
runGitHub( "RLUR", "dwmorley")
shiny::runApp('P:/RLUR/RLUR')
lm.lur
names(lm.lur)
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
length(escape)
nrow(escape)
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
shiny::runApp('P:/RLUR/RLUR')
